{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. python -m mkdocs build git add . git commit -m \"msg\" git push python -m mkdocs gh-deploy","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. python -m mkdocs build git add . git commit -m \"msg\" git push python -m mkdocs gh-deploy","title":"Project layout"},{"location":"cheatengine/cheatengine/","text":"","title":"CheatEngine"},{"location":"cpp/cpp/","text":"","title":"C++"},{"location":"cpp/pointers_references/","text":"Pointers and References A reference is an alias of a variable, while a pointer is a variable holding the address of another variable . To be more exact, a reference is still treated as a pointer by the compiler, that automatically dereferences itself when used, but is much less versatile (but safer!). Usage Use pointers for data structures, address arithmetics and everything else. Use references for function parameters and return types. Example with variables: void incrementBy(int &a, int b) { a = a + b } int main void() { int a = 6; int b = 2; incrementBy(a, b); std::cout << a << std::endl; // prints 8 return EXIT_SUCCESS; } Example with a function: void printMessage(const std::string& message) { std::cout << message << std::endl; } void callFunctionByReference(void (&funcRef)(const std::string&), const std::string& message) { funcRef(message); } int main() { callFunctionByReference(printMessage, \"Hello world!\"); return EXIT_SUCCESS; } Rules int a = 0; int *ptr = &a; // address of a int &ref = a; // a is automatically referenced Accessing the value and address : std::cout << *ptr << std::endl; // displays the value of a std::cout << ref << std::endl; // displays the value of a std::cout << ptr << std::endl; // displays the address of a std::cout << &ref << std::endl; // displays the address of a NULL : A reference cannot be null, a pointer can be. A reference must always be initialized. // valid int *ptr; int *ptr2 = nullptr; // not valid int &ref; Reassignation : A reference cannot be reassigned, a pointer can be. int a; int b; int *ptr = &a; ptr = &b; // valid int *ref = a; ref = b; // not valid Indirection : A reference only offers one level of indirection, whereas pointers offer as many as you want. int a; int *ptr = &a; int **pptr = &ptr; // valid int &ref = a; int &&ref = ref; // not valid Address : References do not have their own memory space, i.e they don't have an address unlike pointers.","title":"Pointers and References"},{"location":"cpp/pointers_references/#pointers-and-references","text":"A reference is an alias of a variable, while a pointer is a variable holding the address of another variable . To be more exact, a reference is still treated as a pointer by the compiler, that automatically dereferences itself when used, but is much less versatile (but safer!).","title":"Pointers and References"},{"location":"cpp/pointers_references/#usage","text":"Use pointers for data structures, address arithmetics and everything else. Use references for function parameters and return types. Example with variables: void incrementBy(int &a, int b) { a = a + b } int main void() { int a = 6; int b = 2; incrementBy(a, b); std::cout << a << std::endl; // prints 8 return EXIT_SUCCESS; } Example with a function: void printMessage(const std::string& message) { std::cout << message << std::endl; } void callFunctionByReference(void (&funcRef)(const std::string&), const std::string& message) { funcRef(message); } int main() { callFunctionByReference(printMessage, \"Hello world!\"); return EXIT_SUCCESS; }","title":"Usage"},{"location":"cpp/pointers_references/#rules","text":"int a = 0; int *ptr = &a; // address of a int &ref = a; // a is automatically referenced Accessing the value and address : std::cout << *ptr << std::endl; // displays the value of a std::cout << ref << std::endl; // displays the value of a std::cout << ptr << std::endl; // displays the address of a std::cout << &ref << std::endl; // displays the address of a NULL : A reference cannot be null, a pointer can be. A reference must always be initialized. // valid int *ptr; int *ptr2 = nullptr; // not valid int &ref; Reassignation : A reference cannot be reassigned, a pointer can be. int a; int b; int *ptr = &a; ptr = &b; // valid int *ref = a; ref = b; // not valid Indirection : A reference only offers one level of indirection, whereas pointers offer as many as you want. int a; int *ptr = &a; int **pptr = &ptr; // valid int &ref = a; int &&ref = ref; // not valid Address : References do not have their own memory space, i.e they don't have an address unlike pointers.","title":"Rules"},{"location":"cpp/type_casting/","text":"Why casting is needed static_cast, reinterpret_cast, ... reinterpret_cast technically is the most unsafe one, but is the one we will mostly use since we are already messing with the memory and trying to forcefully cast values. StackOverflow: When should static_cast, dynamic_cast, const_cast, and reinterpret_cast be used?","title":"Type Casting"},{"location":"cpp/type_casting/#why-casting-is-needed","text":"","title":"Why casting is needed"},{"location":"cpp/type_casting/#static_cast-reinterpret_cast","text":"reinterpret_cast technically is the most unsafe one, but is the one we will mostly use since we are already messing with the memory and trying to forcefully cast values. StackOverflow: When should static_cast, dynamic_cast, const_cast, and reinterpret_cast be used?","title":"static_cast, reinterpret_cast, ..."},{"location":"cpp/vtables/","text":"vtables A vtable (or vftable , for virtual functions table) is how most C++ implementations do polymorphism. class ParentClass { public virtual void virtualFunction() { // Parent Implementation } public virtual void pureVirtualFunction() = 0; } class ChildClass : ParentClass { public override void virtualFunction() { // Child Implementation, overriding's Parent Implementation } } Each class derived from a base class have their own table of function pointers containing all virtual methods they implemented from the base class. When one calls a virtual method, we look up the object's vtable and call the appropriate derived class method. What is a vtable in C++ (StackOverflow) ParentClass ChildClass addr_vtable+0x0 *destructor() *destructor() addr_vtable+0x4 *virtualFunction() *virtualFunction() addr_vtable+0x8 *pureVirtualFunction() The offset of the functions may vary, ParentClass' and ChildClass' virtualFunction() pointers are not necessarily both at addr_vtable+0x4 . ParentClass vtable's pointers to destructor() and virtualFunction() are different from the ones in ChildClass' vtable. Even if we call it a table, a vtable is a list of function pointers, hence why the addresses of each function is incremented by 0x4. The first pointer of a vtable ALWAYS points to the destructor! (write in red) Here, at 0x85A3C4. Why? When a class is created, even if the destructor is not explicitly defined (therefore non-virtual and not part of the vtable), the compiler generates a default destructor. That is, all inheriting classes will inherit this destructor (non-virtual, not in vtable)! Constructors are not in the vtable however, as they cannot be virtual. Note that even if the destructor is defined as non-virtual, it is quite unsafe because of unproper cleanups with the derived classes! Here, most of the guesswork has already been done, but the functions here are natively named FUN_<ADDRESS> . When the decompiled code refers to a function in the vtable, it may appear as object + 0x<Offset> .","title":"vtables"},{"location":"cpp/vtables/#vtables","text":"A vtable (or vftable , for virtual functions table) is how most C++ implementations do polymorphism. class ParentClass { public virtual void virtualFunction() { // Parent Implementation } public virtual void pureVirtualFunction() = 0; } class ChildClass : ParentClass { public override void virtualFunction() { // Child Implementation, overriding's Parent Implementation } } Each class derived from a base class have their own table of function pointers containing all virtual methods they implemented from the base class. When one calls a virtual method, we look up the object's vtable and call the appropriate derived class method. What is a vtable in C++ (StackOverflow) ParentClass ChildClass addr_vtable+0x0 *destructor() *destructor() addr_vtable+0x4 *virtualFunction() *virtualFunction() addr_vtable+0x8 *pureVirtualFunction() The offset of the functions may vary, ParentClass' and ChildClass' virtualFunction() pointers are not necessarily both at addr_vtable+0x4 . ParentClass vtable's pointers to destructor() and virtualFunction() are different from the ones in ChildClass' vtable. Even if we call it a table, a vtable is a list of function pointers, hence why the addresses of each function is incremented by 0x4. The first pointer of a vtable ALWAYS points to the destructor! (write in red) Here, at 0x85A3C4. Why? When a class is created, even if the destructor is not explicitly defined (therefore non-virtual and not part of the vtable), the compiler generates a default destructor. That is, all inheriting classes will inherit this destructor (non-virtual, not in vtable)! Constructors are not in the vtable however, as they cannot be virtual. Note that even if the destructor is defined as non-virtual, it is quite unsafe because of unproper cleanups with the derived classes! Here, most of the guesswork has already been done, but the functions here are natively named FUN_<ADDRESS> . When the decompiled code refers to a function in the vtable, it may appear as object + 0x<Offset> .","title":"vtables"},{"location":"else/create_symlink/","text":"Creating a Symbolic Link (Symlink) A Symbolic Link is a file that points to another file or directory. It is used for \"connecting\" a folder to another, like in the case of assets, you will not be required to move your assets output directory to the project itself. Command line: mklink /D \"C:\\Pictures\\assets\" \"C:\\git\\project\\assets\" The folder in the second string must not exist before! Deleting a SymLink has no effect on any file. It also must be manually updated.","title":"Create a Symbolic Link"},{"location":"else/create_symlink/#creating-a-symbolic-link-symlink","text":"A Symbolic Link is a file that points to another file or directory. It is used for \"connecting\" a folder to another, like in the case of assets, you will not be required to move your assets output directory to the project itself. Command line: mklink /D \"C:\\Pictures\\assets\" \"C:\\git\\project\\assets\" The folder in the second string must not exist before! Deleting a SymLink has no effect on any file. It also must be manually updated.","title":"Creating a Symbolic Link (Symlink)"},{"location":"ghidra/ghidra_setup/","text":"Setting up Ghidra Get the version of your choice here: Ghidra Github Releases Get Java JRE and JDK Install Java JRE (any version should do). For Ghidra 9.1.2 (the one that I use), install between JDK11 and JDK15. Ghidra 10 should support between JDK17 and JDK20.","title":"Setup"},{"location":"ghidra/ghidra_setup/#setting-up-ghidra","text":"Get the version of your choice here: Ghidra Github Releases","title":"Setting up Ghidra"},{"location":"ghidra/ghidra_setup/#get-java-jre-and-jdk","text":"Install Java JRE (any version should do). For Ghidra 9.1.2 (the one that I use), install between JDK11 and JDK15. Ghidra 10 should support between JDK17 and JDK20.","title":"Get Java JRE and JDK"},{"location":"ghidra/hierarchy/","text":"Find the hierarchy of the program To understand what does a part of the program , it is never a bad thing to understand what it does globally. Indeed, a program will have key sections like: the entry point the main loop inputs handling the game logic rendering The entry point .exe files have a common entry point named entry . .DLL files will most likely have an init entry point. Searching more locally Getting the entry point is all good, but not necessarily what you need especially if you are looking for the logic of class methods. Click on a function and hit Shift+F and explore which functions call the one you selected. If there is only one result, you're most probably on a good track, else you will have to dig around. Here, it is called by a pointer of a vtable. If you are looking for the main logic, then better find another function to start from.","title":"Find the Hierarchy"},{"location":"ghidra/hierarchy/#find-the-hierarchy-of-the-program","text":"To understand what does a part of the program , it is never a bad thing to understand what it does globally. Indeed, a program will have key sections like: the entry point the main loop inputs handling the game logic rendering","title":"Find the hierarchy of the program"},{"location":"ghidra/hierarchy/#the-entry-point","text":".exe files have a common entry point named entry . .DLL files will most likely have an init entry point.","title":"The entry point"},{"location":"ghidra/hierarchy/#searching-more-locally","text":"Getting the entry point is all good, but not necessarily what you need especially if you are looking for the logic of class methods. Click on a function and hit Shift+F and explore which functions call the one you selected. If there is only one result, you're most probably on a good track, else you will have to dig around. Here, it is called by a pointer of a vtable. If you are looking for the main logic, then better find another function to start from.","title":"Searching more locally"},{"location":"ghidra/keybinds/","text":"Keybinds I recommend to change some keybinds for making your life easier when navigating the decompiled code: Edit > Tool Options... > Key Bindings and edit the following Previous in History Buffer: change Alt+Left to Ctrl+Left Next in History Buffer: change Alt+Right to Ctrl+Right Find References To Symbol: set it to Shift+F These three features are the core of a smooth search in Ghidra.","title":"Keybinds"},{"location":"ghidra/keybinds/#keybinds","text":"I recommend to change some keybinds for making your life easier when navigating the decompiled code: Edit > Tool Options... > Key Bindings and edit the following Previous in History Buffer: change Alt+Left to Ctrl+Left Next in History Buffer: change Alt+Right to Ctrl+Right Find References To Symbol: set it to Shift+F These three features are the core of a smooth search in Ghidra.","title":"Keybinds"},{"location":"ghidra/naming_conventions/","text":"Ghidra's naming and how to read them FUN_<ADDRESS> : Function at <address> DAT_<ADDRESS> : Data at <address> LAB_<ADDRESS> : Label at <address>, it is a function, struct, data or variable that was not defined by the developer themself. A same var can be used for different purposes. A bit troublesome. 0xffffffff = -1 in unsigned 0x3f000000 = -1 in floating point How to rename without getting lost It is all good being able to navigate in the decompiled code and finding strings, but you need to sort this mess in a human-readable way, for yourself and others. Hit l to rename functions, labels, data or variables. Don't try to rename things you are too unsure of. u_<nameOfYourGuess> for functions, variables or whatever that you aren't sure of. u_ stands for unknown.","title":"Naming conventions"},{"location":"ghidra/naming_conventions/#ghidras-naming-and-how-to-read-them","text":"FUN_<ADDRESS> : Function at <address> DAT_<ADDRESS> : Data at <address> LAB_<ADDRESS> : Label at <address>, it is a function, struct, data or variable that was not defined by the developer themself. A same var can be used for different purposes. A bit troublesome. 0xffffffff = -1 in unsigned 0x3f000000 = -1 in floating point","title":"Ghidra's naming and how to read them"},{"location":"ghidra/naming_conventions/#how-to-rename-without-getting-lost","text":"It is all good being able to navigate in the decompiled code and finding strings, but you need to sort this mess in a human-readable way, for yourself and others. Hit l to rename functions, labels, data or variables. Don't try to rename things you are too unsure of. u_<nameOfYourGuess> for functions, variables or whatever that you aren't sure of. u_ stands for unknown.","title":"How to rename without getting lost"},{"location":"ghidra/new_project/","text":"New Project When launching Ghidra, you are faced with a project launcher. Create a project directory to hold the project you will work in Put a copy of the file you want to examine in this folder File > New Project... in non-shared, indicate the folder you just created and continue Drag&Drop the file onto the launcher where the named folder is Double-click the file to open it The default parameters should be fine, let Ghidra disassemble/decompile your file for a few minutes* You can now start digging *Ghidra may complain that there is no PDB. Ignore it. The PDB is the debugging file only present in the Debug mode of the executable/dll/file, or more realistically only to the original developers. It contains the names of all functions, variables and anything else, and it's precisely because you are missing this file that you will spend hours finding out what this FUN_006452C2 does.","title":"Open a new Project"},{"location":"ghidra/new_project/#new-project","text":"When launching Ghidra, you are faced with a project launcher. Create a project directory to hold the project you will work in Put a copy of the file you want to examine in this folder File > New Project... in non-shared, indicate the folder you just created and continue Drag&Drop the file onto the launcher where the named folder is Double-click the file to open it The default parameters should be fine, let Ghidra disassemble/decompile your file for a few minutes* You can now start digging *Ghidra may complain that there is no PDB. Ignore it. The PDB is the debugging file only present in the Debug mode of the executable/dll/file, or more realistically only to the original developers. It contains the names of all functions, variables and anything else, and it's precisely because you are missing this file that you will spend hours finding out what this FUN_006452C2 does.","title":"New Project"},{"location":"ghidra/search_for_strings/","text":"Search for String One of the fastest and easiest approach when digging through decompiled code is to look for strings. Search > For Strings... with the default parameters should be fine. The strength of this method of approach is that it is really efficient when inspecting code that is very susceptible to have debug functions in it, such as console messages ( std::cout and the likes). Though, you will have to ignore the very many system strings present in the results... However, this method can be unreliable for games as their Release version may not contain any trace of debug logging. Still, a very quick and efficient way to easily guess portions of code.","title":"Search for Strings"},{"location":"ghidra/search_for_strings/#search-for-string","text":"One of the fastest and easiest approach when digging through decompiled code is to look for strings. Search > For Strings... with the default parameters should be fine. The strength of this method of approach is that it is really efficient when inspecting code that is very susceptible to have debug functions in it, such as console messages ( std::cout and the likes). Though, you will have to ignore the very many system strings present in the results... However, this method can be unreliable for games as their Release version may not contain any trace of debug logging. Still, a very quick and efficient way to easily guess portions of code.","title":"Search for String"}]}