{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. python -m mkdocs build git add . git commit -m \"msg\" git push python -m mkdocs gh-deploy","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. python -m mkdocs build git add . git commit -m \"msg\" git push python -m mkdocs gh-deploy","title":"Project layout"},{"location":"cheatengine/cheatengine/","text":"","title":"CheatEngine"},{"location":"cpp/initializer_list/","text":"Member Initializer List Member Initializer List is a mechanism for initializing the members of a class directly. It also enables initializing const members and references, whereas the constructor cannot. Performance class Class { private: // _ is here to indicate a member is private std::string _id; std::string _data; public: Class(const std::string& id, const std::string& data) : _id(id) { this->_data = data; // other operations } } Initializing directly with the values in the initializer list is faster than the constructor giving a default initialization then assigning the values. Initializing this->_data in the constructor function is slower than in the initializer list. You should write: class Class { private: std::string _id; std::string _data; public: Class(const std::string& id, const std::string& data) : _id(id), _data(data) { // other operations } } The members initialized in the list are initialized in the order they are written! Const members and References Const variables and references CANNOT be assigned after initialization. That is, it is not possible to do the following: class Class { private: const int _id; int &_ref; public: Class(const int& id) { _id = id; // not valid ref = id; // not valid } } you must do the following: class Class { private: const int _id; int &_ref; public: Class(const int& id) : _id(id), _ref(id) { // } } int main() { int id = 20; Class obj(id); id = 25; // id is changed, _ref reflects it and _ref = 25 // _id is const and does not change (_id = 20) }","title":"Member Initialization List"},{"location":"cpp/initializer_list/#member-initializer-list","text":"Member Initializer List is a mechanism for initializing the members of a class directly. It also enables initializing const members and references, whereas the constructor cannot.","title":"Member Initializer List"},{"location":"cpp/initializer_list/#performance","text":"class Class { private: // _ is here to indicate a member is private std::string _id; std::string _data; public: Class(const std::string& id, const std::string& data) : _id(id) { this->_data = data; // other operations } } Initializing directly with the values in the initializer list is faster than the constructor giving a default initialization then assigning the values. Initializing this->_data in the constructor function is slower than in the initializer list. You should write: class Class { private: std::string _id; std::string _data; public: Class(const std::string& id, const std::string& data) : _id(id), _data(data) { // other operations } } The members initialized in the list are initialized in the order they are written!","title":"Performance"},{"location":"cpp/initializer_list/#const-members-and-references","text":"Const variables and references CANNOT be assigned after initialization. That is, it is not possible to do the following: class Class { private: const int _id; int &_ref; public: Class(const int& id) { _id = id; // not valid ref = id; // not valid } } you must do the following: class Class { private: const int _id; int &_ref; public: Class(const int& id) : _id(id), _ref(id) { // } } int main() { int id = 20; Class obj(id); id = 25; // id is changed, _ref reflects it and _ref = 25 // _id is const and does not change (_id = 20) }","title":"Const members and References"},{"location":"cpp/lambdas/","text":"Lambda Functions Lambda functions are used for functions that only have a use locally within the function you working in. auto lambda = [captures](parameters) { // content }; The captures refers to the variables present in the enclosing scope. That is: void function() { int b = 2; auto funcionLambda = [&]() { std::cout << b << std::endl; // can only access b }; } int main() { int a = 1; auto mainLambda = [&]() { std::cout << a << std::endl; // can only access a }; function(); } [&] will capture every variable in the scope by reference. To access a by reference, write [&a] . [=] will capture every variable in the scope by value. To access the value of the variable a, write [a] . Example: void function() { int a = 1; int b = 2; int c = 3; auto computeValueA = [&a, b](int number) { // a is captured by reference, and b by value // c is not captured a = a * b + number; }; computeValueA(4) // a is now equal to 1 * 2 + 4 = 6 }","title":"Lambda Functions"},{"location":"cpp/lambdas/#lambda-functions","text":"Lambda functions are used for functions that only have a use locally within the function you working in. auto lambda = [captures](parameters) { // content }; The captures refers to the variables present in the enclosing scope. That is: void function() { int b = 2; auto funcionLambda = [&]() { std::cout << b << std::endl; // can only access b }; } int main() { int a = 1; auto mainLambda = [&]() { std::cout << a << std::endl; // can only access a }; function(); } [&] will capture every variable in the scope by reference. To access a by reference, write [&a] . [=] will capture every variable in the scope by value. To access the value of the variable a, write [a] . Example: void function() { int a = 1; int b = 2; int c = 3; auto computeValueA = [&a, b](int number) { // a is captured by reference, and b by value // c is not captured a = a * b + number; }; computeValueA(4) // a is now equal to 1 * 2 + 4 = 6 }","title":"Lambda Functions"},{"location":"cpp/pointers_references/","text":"Pointers and References A reference is an alias of a variable, while a pointer is a variable holding the address of another variable . To be more exact, a reference is still treated as a pointer by the compiler, that automatically dereferences itself when used, is less versatile than a pointer but safer on its uses cases. Usage Use pointers for data structures, address arithmetics and everything else. Use references for function parameters and return types. Example with variables: void incrementBy(int &a, int b) { a = a + b } int main void() { int a = 6; int b = 2; incrementBy(a, b); std::cout << a << std::endl; // prints 8 return EXIT_SUCCESS; } Example with a function: void printMessage(const std::string& message) { std::cout << message << std::endl; } void callFunctionByReference(void (&funcRef)(const std::string&), const std::string& message) { funcRef(message); } int main() { callFunctionByReference(printMessage, \"Hello world!\"); return EXIT_SUCCESS; } Rules int a = 0; int *ptr = &a; // address of a int &ref = a; // ref is an alias of a Accessing the value and address : std::cout << *ptr << std::endl; // displays the value of a std::cout << ref << std::endl; // displays the value of a std::cout << ptr << std::endl; // displays the address of a std::cout << &ref << std::endl; // displays the address of a NULL : A reference cannot be null, a pointer can be. A reference must always be initialized. // valid int *ptr; int *ptr2 = nullptr; // not valid int &ref; Reassignation : A reference cannot be reassigned after initialization. A pointer can be reassigned as many times as you need. int a; int b; int *ptr = &a; ptr = &b; // valid int *ref = a; ref = b; // not valid Indirection : A reference only offers one level of indirection, whereas pointers offer as many as you want. int a; int *ptr = &a; int **pptr = &ptr; // valid int &ref = a; int &&ref = ref; // not valid Address : References do not have their own memory space, i.e they don't have an address unlike pointers.","title":"Pointers and References"},{"location":"cpp/pointers_references/#pointers-and-references","text":"A reference is an alias of a variable, while a pointer is a variable holding the address of another variable . To be more exact, a reference is still treated as a pointer by the compiler, that automatically dereferences itself when used, is less versatile than a pointer but safer on its uses cases.","title":"Pointers and References"},{"location":"cpp/pointers_references/#usage","text":"Use pointers for data structures, address arithmetics and everything else. Use references for function parameters and return types. Example with variables: void incrementBy(int &a, int b) { a = a + b } int main void() { int a = 6; int b = 2; incrementBy(a, b); std::cout << a << std::endl; // prints 8 return EXIT_SUCCESS; } Example with a function: void printMessage(const std::string& message) { std::cout << message << std::endl; } void callFunctionByReference(void (&funcRef)(const std::string&), const std::string& message) { funcRef(message); } int main() { callFunctionByReference(printMessage, \"Hello world!\"); return EXIT_SUCCESS; }","title":"Usage"},{"location":"cpp/pointers_references/#rules","text":"int a = 0; int *ptr = &a; // address of a int &ref = a; // ref is an alias of a Accessing the value and address : std::cout << *ptr << std::endl; // displays the value of a std::cout << ref << std::endl; // displays the value of a std::cout << ptr << std::endl; // displays the address of a std::cout << &ref << std::endl; // displays the address of a NULL : A reference cannot be null, a pointer can be. A reference must always be initialized. // valid int *ptr; int *ptr2 = nullptr; // not valid int &ref; Reassignation : A reference cannot be reassigned after initialization. A pointer can be reassigned as many times as you need. int a; int b; int *ptr = &a; ptr = &b; // valid int *ref = a; ref = b; // not valid Indirection : A reference only offers one level of indirection, whereas pointers offer as many as you want. int a; int *ptr = &a; int **pptr = &ptr; // valid int &ref = a; int &&ref = ref; // not valid Address : References do not have their own memory space, i.e they don't have an address unlike pointers.","title":"Rules"},{"location":"cpp/smart_pointers/","text":"Smart Pointers (C++11) We will focus on heap-allocated objects . Common problems with raw pointers Raw pointers do not go out of scope, therefore are not destroyed automatically, this causes: - Memory leaks: the user forgets to delete and the memory can overflow - Dangling pointers: a pointer points to an address that has been deallocated - Wild pointers: a pointer may have not been initialized to point to a valid address or object delete calls the destructor of the object first then deallocate the memory the pointer was pointing to When allocated in the heap, the object can take as much memory as the OS can provide, and must be manually deleted . Class *obj = new Class(); // allocated in the heap When allocated in the stack, the object is destroyed when going out of scope, but is limited to the size of the stack itself (a few Megabytes). Stack-allocated objects are typically used when they won't live beyond the scope of the current function. //Class obj(); // allocated in the stack How Smart Pointers solve these issues Include #include <memory> to use smart pointers. Smart pointers are pointers that are self-managed, that is to say they will delete when: - they go out of scope - they call reset() However, smart pointers are mostly used with heap-allocated objects as the stack has its own rules of ownership and deallocation. std::unique_ptr (deprecates auto_ptr) A unique_ptr has exclusive ownership of a dynamically allocated object. If another pointer tries to copy or assign itself to the object, the compiler will raise an error. Has less overhead than shared_ptr and usually more efficient. auto obj = std::make_unique<Class>(); std::shared_ptr A shared_ptr allows multiple smart pointers to share the ownership of the object, and keeps track of how many smart pointers are pointing towards the object with use_count() . auto sharedPtr = std::make_shared<Class>(); std::weak_ptr Typically used to break circular dependency of shared pointers. Otherwise not very common. auto obj = std::make_weak<Class>();","title":"Smart Pointers"},{"location":"cpp/smart_pointers/#smart-pointers-c11","text":"We will focus on heap-allocated objects .","title":"Smart Pointers (C++11)"},{"location":"cpp/smart_pointers/#common-problems-with-raw-pointers","text":"Raw pointers do not go out of scope, therefore are not destroyed automatically, this causes: - Memory leaks: the user forgets to delete and the memory can overflow - Dangling pointers: a pointer points to an address that has been deallocated - Wild pointers: a pointer may have not been initialized to point to a valid address or object delete calls the destructor of the object first then deallocate the memory the pointer was pointing to When allocated in the heap, the object can take as much memory as the OS can provide, and must be manually deleted . Class *obj = new Class(); // allocated in the heap When allocated in the stack, the object is destroyed when going out of scope, but is limited to the size of the stack itself (a few Megabytes). Stack-allocated objects are typically used when they won't live beyond the scope of the current function. //Class obj(); // allocated in the stack","title":"Common problems with raw pointers"},{"location":"cpp/smart_pointers/#how-smart-pointers-solve-these-issues","text":"Include #include <memory> to use smart pointers. Smart pointers are pointers that are self-managed, that is to say they will delete when: - they go out of scope - they call reset() However, smart pointers are mostly used with heap-allocated objects as the stack has its own rules of ownership and deallocation.","title":"How Smart Pointers solve these issues"},{"location":"cpp/smart_pointers/#stdunique_ptr-deprecates-auto_ptr","text":"A unique_ptr has exclusive ownership of a dynamically allocated object. If another pointer tries to copy or assign itself to the object, the compiler will raise an error. Has less overhead than shared_ptr and usually more efficient. auto obj = std::make_unique<Class>();","title":"std::unique_ptr (deprecates auto_ptr)"},{"location":"cpp/smart_pointers/#stdshared_ptr","text":"A shared_ptr allows multiple smart pointers to share the ownership of the object, and keeps track of how many smart pointers are pointing towards the object with use_count() . auto sharedPtr = std::make_shared<Class>();","title":"std::shared_ptr"},{"location":"cpp/smart_pointers/#stdweak_ptr","text":"Typically used to break circular dependency of shared pointers. Otherwise not very common. auto obj = std::make_weak<Class>();","title":"std::weak_ptr"},{"location":"cpp/type_casting/","text":"Why casting is needed static_cast, reinterpret_cast, ... reinterpret_cast technically is the most unsafe one, but is the one we will mostly use since we are already messing with the memory and trying to forcefully cast values. StackOverflow: When should static_cast, dynamic_cast, const_cast, and reinterpret_cast be used?","title":"Type Casting"},{"location":"cpp/type_casting/#why-casting-is-needed","text":"","title":"Why casting is needed"},{"location":"cpp/type_casting/#static_cast-reinterpret_cast","text":"reinterpret_cast technically is the most unsafe one, but is the one we will mostly use since we are already messing with the memory and trying to forcefully cast values. StackOverflow: When should static_cast, dynamic_cast, const_cast, and reinterpret_cast be used?","title":"static_cast, reinterpret_cast, ..."},{"location":"cpp/vtables/","text":"vtables A vtable (or vftable , for virtual functions table) is how most C++ implementations do polymorphism. class ParentClass { public virtual void virtualFunction() { // Parent Implementation } public virtual void pureVirtualFunction() = 0; } class ChildClass : ParentClass { public override void virtualFunction() { // Child Implementation, overriding's Parent Implementation } } Each class derived from a base class have their own table of function pointers containing all virtual methods they implemented from the base class. When one calls a virtual method, we look up the object's vtable and call the appropriate derived class method. What is a vtable in C++ (StackOverflow) ParentClass ChildClass addr_vtable+0x0 *destructor() *destructor() addr_vtable+0x4 *virtualFunction() *virtualFunction() addr_vtable+0x8 *pureVirtualFunction() The offset of the functions may vary, ParentClass' and ChildClass' virtualFunction() pointers are not necessarily both at addr_vtable+0x4 . ParentClass vtable's pointers to destructor() and virtualFunction() are different from the ones in ChildClass' vtable. Even if we call it a table, a vtable is a list of function pointers, hence why the addresses of each function is incremented by 0x4. The first pointer of a vtable ALWAYS points to the destructor! (write in red) Here, at 0x85A3C4. Why? When a class is created, even if the destructor is not explicitly defined (therefore non-virtual and not part of the vtable), the compiler generates a default destructor. That is, all inheriting classes will inherit this destructor (non-virtual, not in vtable)! Constructors are not in the vtable however, as they cannot be virtual. Note that even if the destructor is defined as non-virtual, it is quite unsafe because of unproper cleanups with the derived classes! Here, most of the guesswork has already been done, but the functions here are natively named FUN_<ADDRESS> . When the decompiled code refers to a function in the vtable, it may appear as object + 0x<Offset> .","title":"vtables"},{"location":"cpp/vtables/#vtables","text":"A vtable (or vftable , for virtual functions table) is how most C++ implementations do polymorphism. class ParentClass { public virtual void virtualFunction() { // Parent Implementation } public virtual void pureVirtualFunction() = 0; } class ChildClass : ParentClass { public override void virtualFunction() { // Child Implementation, overriding's Parent Implementation } } Each class derived from a base class have their own table of function pointers containing all virtual methods they implemented from the base class. When one calls a virtual method, we look up the object's vtable and call the appropriate derived class method. What is a vtable in C++ (StackOverflow) ParentClass ChildClass addr_vtable+0x0 *destructor() *destructor() addr_vtable+0x4 *virtualFunction() *virtualFunction() addr_vtable+0x8 *pureVirtualFunction() The offset of the functions may vary, ParentClass' and ChildClass' virtualFunction() pointers are not necessarily both at addr_vtable+0x4 . ParentClass vtable's pointers to destructor() and virtualFunction() are different from the ones in ChildClass' vtable. Even if we call it a table, a vtable is a list of function pointers, hence why the addresses of each function is incremented by 0x4. The first pointer of a vtable ALWAYS points to the destructor! (write in red) Here, at 0x85A3C4. Why? When a class is created, even if the destructor is not explicitly defined (therefore non-virtual and not part of the vtable), the compiler generates a default destructor. That is, all inheriting classes will inherit this destructor (non-virtual, not in vtable)! Constructors are not in the vtable however, as they cannot be virtual. Note that even if the destructor is defined as non-virtual, it is quite unsafe because of unproper cleanups with the derived classes! Here, most of the guesswork has already been done, but the functions here are natively named FUN_<ADDRESS> . When the decompiled code refers to a function in the vtable, it may appear as object + 0x<Offset> .","title":"vtables"},{"location":"else/create_symlink/","text":"Creating a Symbolic Link (Symlink) A Symbolic Link is a file that points to another file or directory. It is used for \"connecting\" a folder to another, like in the case of assets, you will not be required to move your assets output directory to the project itself. Command line: mklink /D \"C:\\Pictures\\assets\" \"C:\\git\\project\\assets\" The folder in the second string must not exist before! Deleting a SymLink has no effect on any file. It also must be manually updated.","title":"Create a Symbolic Link"},{"location":"else/create_symlink/#creating-a-symbolic-link-symlink","text":"A Symbolic Link is a file that points to another file or directory. It is used for \"connecting\" a folder to another, like in the case of assets, you will not be required to move your assets output directory to the project itself. Command line: mklink /D \"C:\\Pictures\\assets\" \"C:\\git\\project\\assets\" The folder in the second string must not exist before! Deleting a SymLink has no effect on any file. It also must be manually updated.","title":"Creating a Symbolic Link (Symlink)"},{"location":"ghidra/ghidra_setup/","text":"Setting up Ghidra Get the version of your choice here: Ghidra Github Releases Get Java JRE and JDK Install Java JRE (any version should do). For Ghidra 9.1.2 (the one that I use), install between JDK11 and JDK15. Ghidra 10 should support between JDK17 and JDK20.","title":"Setup"},{"location":"ghidra/ghidra_setup/#setting-up-ghidra","text":"Get the version of your choice here: Ghidra Github Releases","title":"Setting up Ghidra"},{"location":"ghidra/ghidra_setup/#get-java-jre-and-jdk","text":"Install Java JRE (any version should do). For Ghidra 9.1.2 (the one that I use), install between JDK11 and JDK15. Ghidra 10 should support between JDK17 and JDK20.","title":"Get Java JRE and JDK"},{"location":"ghidra/hierarchy/","text":"Find the hierarchy of the program To understand what does a part of the program , it is never a bad thing to understand what it does globally. Indeed, a program will have key sections like: the entry point the main loop inputs handling the game logic rendering The entry point .exe files have a common entry point named entry . .DLL files will most likely have an init entry point. Searching more locally Getting the entry point is all good, but not necessarily what you need especially if you are looking for the logic of class methods. Click on a function and hit Shift+F and explore which functions call the one you selected. If there is only one result, you're most probably on a good track, else you will have to dig around. Here, it is called by a pointer of a vtable. If you are looking for the main logic, then better find another function to start from.","title":"Find the Hierarchy"},{"location":"ghidra/hierarchy/#find-the-hierarchy-of-the-program","text":"To understand what does a part of the program , it is never a bad thing to understand what it does globally. Indeed, a program will have key sections like: the entry point the main loop inputs handling the game logic rendering","title":"Find the hierarchy of the program"},{"location":"ghidra/hierarchy/#the-entry-point","text":".exe files have a common entry point named entry . .DLL files will most likely have an init entry point.","title":"The entry point"},{"location":"ghidra/hierarchy/#searching-more-locally","text":"Getting the entry point is all good, but not necessarily what you need especially if you are looking for the logic of class methods. Click on a function and hit Shift+F and explore which functions call the one you selected. If there is only one result, you're most probably on a good track, else you will have to dig around. Here, it is called by a pointer of a vtable. If you are looking for the main logic, then better find another function to start from.","title":"Searching more locally"},{"location":"ghidra/keybinds/","text":"Keybinds I recommend to change some keybinds for making your life easier when navigating the decompiled code: Edit > Tool Options... > Key Bindings and edit the following Previous in History Buffer: change Alt+Left to Ctrl+Left Next in History Buffer: change Alt+Right to Ctrl+Right Find References To Symbol: set it to Shift+F These three features are the core of a smooth search in Ghidra.","title":"Keybinds"},{"location":"ghidra/keybinds/#keybinds","text":"I recommend to change some keybinds for making your life easier when navigating the decompiled code: Edit > Tool Options... > Key Bindings and edit the following Previous in History Buffer: change Alt+Left to Ctrl+Left Next in History Buffer: change Alt+Right to Ctrl+Right Find References To Symbol: set it to Shift+F These three features are the core of a smooth search in Ghidra.","title":"Keybinds"},{"location":"ghidra/naming_conventions/","text":"Ghidra's naming and how to read them FUN_<ADDRESS> : Function at <address> DAT_<ADDRESS> : Data at <address> LAB_<ADDRESS> : Label at <address>, it is a function, struct, data or variable that was not defined by the developer themself. A same var can be used for different purposes. A bit troublesome. 0xffffffff = -1 in unsigned 0xbf800000 = -1 in floating point 0x3f800000 = 1 in floating point How to rename without getting lost It is all good being able to navigate in the decompiled code and finding strings, but you need to sort this mess in a human-readable way, for yourself and others. Hit l to rename functions, labels, data or variables. Don't try to rename things you are too unsure of. u_<nameOfYourGuess> for functions, variables or whatever that you aren't sure of. u_ stands for unknown.","title":"Naming conventions"},{"location":"ghidra/naming_conventions/#ghidras-naming-and-how-to-read-them","text":"FUN_<ADDRESS> : Function at <address> DAT_<ADDRESS> : Data at <address> LAB_<ADDRESS> : Label at <address>, it is a function, struct, data or variable that was not defined by the developer themself. A same var can be used for different purposes. A bit troublesome. 0xffffffff = -1 in unsigned 0xbf800000 = -1 in floating point 0x3f800000 = 1 in floating point","title":"Ghidra's naming and how to read them"},{"location":"ghidra/naming_conventions/#how-to-rename-without-getting-lost","text":"It is all good being able to navigate in the decompiled code and finding strings, but you need to sort this mess in a human-readable way, for yourself and others. Hit l to rename functions, labels, data or variables. Don't try to rename things you are too unsure of. u_<nameOfYourGuess> for functions, variables or whatever that you aren't sure of. u_ stands for unknown.","title":"How to rename without getting lost"},{"location":"ghidra/new_project/","text":"New Project When launching Ghidra, you are faced with a project launcher. Create a project directory to hold the project you will work in Put a copy of the file you want to examine in this folder File > New Project... in non-shared, indicate the folder you just created and continue Drag&Drop the file onto the launcher where the named folder is Double-click the file to open it The default parameters should be fine, let Ghidra disassemble/decompile your file for a few minutes* You can now start digging *Ghidra may complain that there is no PDB. Ignore it. The PDB is the debugging file only present in the Debug mode of the executable/dll/file, or more realistically only to the original developers. It contains the names of all functions, variables and anything else, and it's precisely because you are missing this file that you will spend hours finding out what this FUN_006452C2 does.","title":"Open a new Project"},{"location":"ghidra/new_project/#new-project","text":"When launching Ghidra, you are faced with a project launcher. Create a project directory to hold the project you will work in Put a copy of the file you want to examine in this folder File > New Project... in non-shared, indicate the folder you just created and continue Drag&Drop the file onto the launcher where the named folder is Double-click the file to open it The default parameters should be fine, let Ghidra disassemble/decompile your file for a few minutes* You can now start digging *Ghidra may complain that there is no PDB. Ignore it. The PDB is the debugging file only present in the Debug mode of the executable/dll/file, or more realistically only to the original developers. It contains the names of all functions, variables and anything else, and it's precisely because you are missing this file that you will spend hours finding out what this FUN_006452C2 does.","title":"New Project"},{"location":"ghidra/search_for_strings/","text":"Search for String One of the fastest and easiest approach when digging through decompiled code is to look for strings. Search > For Strings... with the default parameters should be fine. The strength of this method of approach is that it is really efficient when inspecting code that is very susceptible to have debug functions in it, such as console messages ( std::cout and the likes). Though, you will have to ignore the very many system strings present in the results... However, this method can be unreliable for games as their Release version may not contain any trace of debug logging. Still, a very quick and efficient way to easily guess portions of code.","title":"Search for Strings"},{"location":"ghidra/search_for_strings/#search-for-string","text":"One of the fastest and easiest approach when digging through decompiled code is to look for strings. Search > For Strings... with the default parameters should be fine. The strength of this method of approach is that it is really efficient when inspecting code that is very susceptible to have debug functions in it, such as console messages ( std::cout and the likes). Though, you will have to ignore the very many system strings present in the results... However, this method can be unreliable for games as their Release version may not contain any trace of debug logging. Still, a very quick and efficient way to easily guess portions of code.","title":"Search for String"}]}