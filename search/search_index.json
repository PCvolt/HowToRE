{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"cheatengine/cheatengine/","text":"","title":"CheatEngine"},{"location":"cpp/cpp/","text":"","title":"C++"},{"location":"cpp/type_casting/","text":"Why casting is needed static_cast, reinterpret_cast, ... reinterpret_cast technically is the most unsafe one, but is the one we will mostly use since we are already messing with the memory and trying to forcefully cast values. StackOverflow: When should static_cast, dynamic_cast, const_cast, and reinterpret_cast be used?","title":"Type Casting"},{"location":"cpp/type_casting/#why-casting-is-needed","text":"","title":"Why casting is needed"},{"location":"cpp/type_casting/#static_cast-reinterpret_cast","text":"reinterpret_cast technically is the most unsafe one, but is the one we will mostly use since we are already messing with the memory and trying to forcefully cast values. StackOverflow: When should static_cast, dynamic_cast, const_cast, and reinterpret_cast be used?","title":"static_cast, reinterpret_cast, ..."},{"location":"cpp/vtables/","text":"vtables A vtable (or vftable , for virtual functions table) is how most C++ implementations do polymorphism. class ParentClass { public virtual void virtualFunction() { // Parent Implementation } public virtual void pureVirtualFunction() = 0; } class ChildClass : ParentClass { public override void virtualFunction() { // Child Implementation, overriding's Parent Implementation } } Each class derived from a base class have their own table of function pointers containing all virtual methods they implemented from the base class. When one calls a virtual method, we look up the object's vtable and call the appropriate derived class method. What is a vtable in C++ (StackOverflow) ParentClass ChildClass addr_vtable+0x0 *destructor() *destructor() addr_vtable+0x4 *virtualFunction() *virtualFunction() addr_vtable+0x8 *pureVirtualFunction() The offset of the functions may vary, ParentClass' and ChildClass' virtualFunction() pointers are not necessarily both at addr_vtable+0x4 . ParentClass vtable's pointers to destructor() and virtualFunction() are different from the ones in ChildClass' vtable. Even if we call it a table, a vtable is a list of function pointers, hence why the addresses of each function is incremented by 0x4. The first pointer of a vtable ALWAYS points to the destructor! (write in red) Here, at 0x85A3C4. Why? When a class is created, even if the destructor is not explicitly defined, the compiler generates a default destructor. That is, all inheriting classes will inherit this destructor! Constructors are not in the vtable however, as they cannot be virtual. Note: the destructor may be non-virtual (therefore not part of the vtable), but that is quite unsafe when dealing with derived classes because of unproper cleanups! Here, most of the guesswork has already been done, but the functions here are natively named FUN_<ADDRESS> . When the decompiled code refers to a function in the vtable, it may appear as object + 0x<Offset> .","title":"vtables"},{"location":"cpp/vtables/#vtables","text":"A vtable (or vftable , for virtual functions table) is how most C++ implementations do polymorphism. class ParentClass { public virtual void virtualFunction() { // Parent Implementation } public virtual void pureVirtualFunction() = 0; } class ChildClass : ParentClass { public override void virtualFunction() { // Child Implementation, overriding's Parent Implementation } } Each class derived from a base class have their own table of function pointers containing all virtual methods they implemented from the base class. When one calls a virtual method, we look up the object's vtable and call the appropriate derived class method. What is a vtable in C++ (StackOverflow) ParentClass ChildClass addr_vtable+0x0 *destructor() *destructor() addr_vtable+0x4 *virtualFunction() *virtualFunction() addr_vtable+0x8 *pureVirtualFunction() The offset of the functions may vary, ParentClass' and ChildClass' virtualFunction() pointers are not necessarily both at addr_vtable+0x4 . ParentClass vtable's pointers to destructor() and virtualFunction() are different from the ones in ChildClass' vtable. Even if we call it a table, a vtable is a list of function pointers, hence why the addresses of each function is incremented by 0x4. The first pointer of a vtable ALWAYS points to the destructor! (write in red) Here, at 0x85A3C4. Why? When a class is created, even if the destructor is not explicitly defined, the compiler generates a default destructor. That is, all inheriting classes will inherit this destructor! Constructors are not in the vtable however, as they cannot be virtual. Note: the destructor may be non-virtual (therefore not part of the vtable), but that is quite unsafe when dealing with derived classes because of unproper cleanups! Here, most of the guesswork has already been done, but the functions here are natively named FUN_<ADDRESS> . When the decompiled code refers to a function in the vtable, it may appear as object + 0x<Offset> .","title":"vtables"},{"location":"else/create_symlink/","text":"Creating a Symbolic Link (Symlink) A Symbolic Link is a file that points to another file or directory. It is used for \"connecting\" a folder to another, like in the case of assets, you will not be required to move your assets output directory to the project itself. Command line: mklink /D \"C:\\Pictures\\assets\" \"C:\\git\\project\\assets\" The folder in the second string must not exist before! Deleting a SymLink has no effect on any file. It also must be manually updated.","title":"Create a Symbolic Link"},{"location":"else/create_symlink/#creating-a-symbolic-link-symlink","text":"A Symbolic Link is a file that points to another file or directory. It is used for \"connecting\" a folder to another, like in the case of assets, you will not be required to move your assets output directory to the project itself. Command line: mklink /D \"C:\\Pictures\\assets\" \"C:\\git\\project\\assets\" The folder in the second string must not exist before! Deleting a SymLink has no effect on any file. It also must be manually updated.","title":"Creating a Symbolic Link (Symlink)"},{"location":"ghidra/ghidra_setup/","text":"Setting up Ghidra Get the version of your choice here: Ghidra Github Releases Get Java JRE and JDK Install Java JRE (any version should do). For Ghidra 9.1.2 (the one that I use), install between JDK11 and JDK15. Ghidra 10 should support between JDK17 and JDK20.","title":"Setup"},{"location":"ghidra/ghidra_setup/#setting-up-ghidra","text":"Get the version of your choice here: Ghidra Github Releases","title":"Setting up Ghidra"},{"location":"ghidra/ghidra_setup/#get-java-jre-and-jdk","text":"Install Java JRE (any version should do). For Ghidra 9.1.2 (the one that I use), install between JDK11 and JDK15. Ghidra 10 should support between JDK17 and JDK20.","title":"Get Java JRE and JDK"},{"location":"ghidra/hierarchy/","text":"Find the hierarchy of the program To understand what does a part of the program , it is never a bad thing to understand what it does globally. Indeed, a program will have key sections like: the entry point the main loop inputs handling the game logic rendering The entry point .exe files have a common entry point named .entry . .DLL files will most likely have an init entry point. Searching more locally Getting the entry point is all good, but not necessarily what you need especially if you are looking for the logic of class methods. Click on a function and hit Shift+F and explore which functions call the one you selected. If there is only one result, you're most probably on a good track, else you will have to dig around. Here, it is called by a pointer of a vtable. If you are looking for the main logic, then better find another function to start from.","title":"Find the Hierarchy"},{"location":"ghidra/hierarchy/#find-the-hierarchy-of-the-program","text":"To understand what does a part of the program , it is never a bad thing to understand what it does globally. Indeed, a program will have key sections like: the entry point the main loop inputs handling the game logic rendering","title":"Find the hierarchy of the program"},{"location":"ghidra/hierarchy/#the-entry-point","text":".exe files have a common entry point named .entry . .DLL files will most likely have an init entry point.","title":"The entry point"},{"location":"ghidra/hierarchy/#searching-more-locally","text":"Getting the entry point is all good, but not necessarily what you need especially if you are looking for the logic of class methods. Click on a function and hit Shift+F and explore which functions call the one you selected. If there is only one result, you're most probably on a good track, else you will have to dig around. Here, it is called by a pointer of a vtable. If you are looking for the main logic, then better find another function to start from.","title":"Searching more locally"},{"location":"ghidra/keybinds/","text":"Keybinds I recommend to change some keybinds for making your life easier when navigating the decompiled code: Edit > Tool Options... > Key Bindings and edit the following Previous in History Buffer: change Alt+Left to Ctrl+Left Next in History Buffer: change Alt+Right to Ctrl+Right Find References To Symbol: set it to Shift+F These three features are the core of a smooth search in Ghidra.","title":"Keybinds"},{"location":"ghidra/keybinds/#keybinds","text":"I recommend to change some keybinds for making your life easier when navigating the decompiled code: Edit > Tool Options... > Key Bindings and edit the following Previous in History Buffer: change Alt+Left to Ctrl+Left Next in History Buffer: change Alt+Right to Ctrl+Right Find References To Symbol: set it to Shift+F These three features are the core of a smooth search in Ghidra.","title":"Keybinds"},{"location":"ghidra/naming_conventions/","text":"Ghidra's naming and how to read them FUN_<ADDRESS> : Function at <address> LAB_<ADDRESS> : Label at <address>, can represent a function. DAT_<ADDRESS> : Data at <address> A same var can be used for different purposes. A bit troublesome. 0xffffffff = -1 in unsigned 0x3f000000 = -1 in floating point How to rename without getting lost u_<nameOfYourGuess> for functions, variables or whatever that you aren't sure of. u_ stands for unknown. Don't try to rename things you are too unsure of.","title":"Naming conventions"},{"location":"ghidra/naming_conventions/#ghidras-naming-and-how-to-read-them","text":"FUN_<ADDRESS> : Function at <address> LAB_<ADDRESS> : Label at <address>, can represent a function. DAT_<ADDRESS> : Data at <address> A same var can be used for different purposes. A bit troublesome. 0xffffffff = -1 in unsigned 0x3f000000 = -1 in floating point","title":"Ghidra's naming and how to read them"},{"location":"ghidra/naming_conventions/#how-to-rename-without-getting-lost","text":"u_<nameOfYourGuess> for functions, variables or whatever that you aren't sure of. u_ stands for unknown. Don't try to rename things you are too unsure of.","title":"How to rename without getting lost"},{"location":"ghidra/search_for_strings/","text":"Search for String One of the fastest and easiest approach when digging through decompiled code is to look for strings. Search > For Strings... with the default parameters should be fine. The strength of this method of approach is that it is really efficient when inspecting code that is very susceptible to have debug functions in it, such as console messages ( std::cout and the likes). Though, you will have to ignore the very many system strings present in the results... However, this method can be unreliable for games as their Release version may not contain any trace of debug logging. Still, a very quick and efficient way to easily guess portions of code.","title":"Search for Strings"},{"location":"ghidra/search_for_strings/#search-for-string","text":"One of the fastest and easiest approach when digging through decompiled code is to look for strings. Search > For Strings... with the default parameters should be fine. The strength of this method of approach is that it is really efficient when inspecting code that is very susceptible to have debug functions in it, such as console messages ( std::cout and the likes). Though, you will have to ignore the very many system strings present in the results... However, this method can be unreliable for games as their Release version may not contain any trace of debug logging. Still, a very quick and efficient way to easily guess portions of code.","title":"Search for String"}]}