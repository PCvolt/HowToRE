{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. python -m mkdocs build git add . git commit -m \"msg\" git push python -m mkdocs gh-deploy","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. python -m mkdocs build git add . git commit -m \"msg\" git push python -m mkdocs gh-deploy","title":"Project layout"},{"location":"ASM/compiler_linker/","text":"What is a binary A binary is a file which data is purely intended to be read by the machine (0 and 1, beep boop). It can be many things and usually have an extension name so that the user knows which programs can reinterpret it this data (e.g a .psd is meant to be read by Photoshop). It is mostly used to speak of .exe files in the programming world. By extension the \\bin folder is where the output .exe is stored. Compilers (and Assemblers) A compiler is a program that translates the source code (C, C++, Java, Python, etc.) into machine code (binary) to be executed by the CPU. There are many compilers out there: - GCC: Linux, Windows (through MinGW or Cygwin), MacOS - Clang: Linux, Windows, MacOS - MSVC: Windows / C and C++ only - ICC: Linux, Windows, MacOS - A lot of other ones, but usually the aforementioned ones are the only ones you will realistically meet What makes those compilers different from each other? - Supported languages and standards (MSVC only supports C and C++) - Different optimizations (ICC optimized for Intel) - Error reports and diagnostics (GCC I'm looking at you) - Toolchain and Ecosystem (MSVC ) - Performance An assembler is just like a compiler, but for ASM! Some assemblers to know of: - GNU Assembler (GAS) - NASM (Netwide Assembler) - MASM (Microsoft Macro Assembler) Both compilers and assemblers can produce object files ( .o for Linux, or .obj for Windows) If there is only a single file with no dependencies whatsoever, they can produce an executable. They however cannot directly produce libraries at all. In the context of Reverse Engineering, a decompiler/disassembler is a program that takes whatever result a compiler/assembler produced, and tries to write the source code in C/C++ or in ASM. Linkers Since the compiler creates a .o / .obj for each .cpp file you write, you end up with many object files. The linker's job is to: - combine all of these object files into a final output - resolve symbols, meaning all function and variable calls are correctly made across all files - binding addresses properly when loading libraries in memory The final output can be: - executables: (Linux) or .exe (Windows) - debug symbols: .debug or others (Linux) or .pdb (Windows) - archive / static libraries: .a (Linux) or .lib (Windows) - shared object / dynamic libraries: .so (Linux) .dll (Windows) Static Library or Dynamic Library? Libraries are meant to modularize and single out the responsibilities of different parts of the code. A .lib is bundled with the main code after linking, meaning it increases the size of the final binary, itis always loaded and has the same version as the main code. Still, a .lib can be reused in other projects without duplicating. A .dll remains its own separate file, loaded only when asked for, and with its own version. On the other hand, if the .dll file is absent, the binary cannot run. For Reverse Engineering, .dll are our friend. Reading a DLL In x86 Native Tools Command Prompt for VS 2022 (or earlier version), call dumpbin /EXPORTS path\\to\\your\\library.dll .","title":"Compiler & Linker"},{"location":"ASM/compiler_linker/#what-is-a-binary","text":"A binary is a file which data is purely intended to be read by the machine (0 and 1, beep boop). It can be many things and usually have an extension name so that the user knows which programs can reinterpret it this data (e.g a .psd is meant to be read by Photoshop). It is mostly used to speak of .exe files in the programming world. By extension the \\bin folder is where the output .exe is stored.","title":"What is a binary"},{"location":"ASM/compiler_linker/#compilers-and-assemblers","text":"A compiler is a program that translates the source code (C, C++, Java, Python, etc.) into machine code (binary) to be executed by the CPU. There are many compilers out there: - GCC: Linux, Windows (through MinGW or Cygwin), MacOS - Clang: Linux, Windows, MacOS - MSVC: Windows / C and C++ only - ICC: Linux, Windows, MacOS - A lot of other ones, but usually the aforementioned ones are the only ones you will realistically meet What makes those compilers different from each other? - Supported languages and standards (MSVC only supports C and C++) - Different optimizations (ICC optimized for Intel) - Error reports and diagnostics (GCC I'm looking at you) - Toolchain and Ecosystem (MSVC ) - Performance An assembler is just like a compiler, but for ASM! Some assemblers to know of: - GNU Assembler (GAS) - NASM (Netwide Assembler) - MASM (Microsoft Macro Assembler) Both compilers and assemblers can produce object files ( .o for Linux, or .obj for Windows) If there is only a single file with no dependencies whatsoever, they can produce an executable. They however cannot directly produce libraries at all. In the context of Reverse Engineering, a decompiler/disassembler is a program that takes whatever result a compiler/assembler produced, and tries to write the source code in C/C++ or in ASM.","title":"Compilers (and Assemblers)"},{"location":"ASM/compiler_linker/#linkers","text":"Since the compiler creates a .o / .obj for each .cpp file you write, you end up with many object files. The linker's job is to: - combine all of these object files into a final output - resolve symbols, meaning all function and variable calls are correctly made across all files - binding addresses properly when loading libraries in memory The final output can be: - executables: (Linux) or .exe (Windows) - debug symbols: .debug or others (Linux) or .pdb (Windows) - archive / static libraries: .a (Linux) or .lib (Windows) - shared object / dynamic libraries: .so (Linux) .dll (Windows)","title":"Linkers"},{"location":"ASM/compiler_linker/#static-library-or-dynamic-library","text":"Libraries are meant to modularize and single out the responsibilities of different parts of the code. A .lib is bundled with the main code after linking, meaning it increases the size of the final binary, itis always loaded and has the same version as the main code. Still, a .lib can be reused in other projects without duplicating. A .dll remains its own separate file, loaded only when asked for, and with its own version. On the other hand, if the .dll file is absent, the binary cannot run. For Reverse Engineering, .dll are our friend.","title":"Static Library or Dynamic Library?"},{"location":"ASM/compiler_linker/#reading-a-dll","text":"In x86 Native Tools Command Prompt for VS 2022 (or earlier version), call dumpbin /EXPORTS path\\to\\your\\library.dll .","title":"Reading a DLL"},{"location":"ASM/registers/","text":"Registers A common depiction of the registers is as follow: Register Usage EAX General purposes / return value EBX General purposes ECX General purposes EDX General purposes ESI General purposes EDI General purposes ESP Stack Pointer EBP Base Pointer EAX is a general-purpose register, but is commonly used to store the return value of a function EBX to EDI are general-purposes registers ESP is the Stack Pointer , it points to the top of the stack EBP is the Base Pointer , it is set at ESP at the beginning of a function (beginning of a stack frame) EIP is the Instruction Pointer , it is a special register which points to the next instruction to execute in the code, useful to look at when using CheatEngine","title":"Registers"},{"location":"ASM/registers/#registers","text":"A common depiction of the registers is as follow: Register Usage EAX General purposes / return value EBX General purposes ECX General purposes EDX General purposes ESI General purposes EDI General purposes ESP Stack Pointer EBP Base Pointer EAX is a general-purpose register, but is commonly used to store the return value of a function EBX to EDI are general-purposes registers ESP is the Stack Pointer , it points to the top of the stack EBP is the Base Pointer , it is set at ESP at the beginning of a function (beginning of a stack frame) EIP is the Instruction Pointer , it is a special register which points to the next instruction to execute in the code, useful to look at when using CheatEngine","title":"Registers"},{"location":"ASM/stack/","text":"","title":"Stack"},{"location":"cheatengine/cheatengine/","text":"","title":"CheatEngine"},{"location":"cpp/initializer_list/","text":"Member Initializer List Member Initializer List is a mechanism for initializing the members of a class directly. It also enables initializing const members and references, whereas the constructor cannot. Performance class Class { private: // _ is here to indicate a member is private std::string _id; std::string _data; public: Class(const std::string& id, const std::string& data) : _id(id) { this->_data = data; // other operations } }; Initializing directly with the values in the initializer list is faster than the constructor giving a default initialization then assigning the values. Initializing this->_data in the constructor function is slower than in the initializer list. You should write: class Class { private: std::string _id; std::string _data; public: Class(const std::string& id, const std::string& data) : _id(id), _data(data) { // other operations } }; The members initialized in the list are initialized in the order they are written! Const members and References Const variables and references CANNOT be assigned after initialization. That is, it is not possible to do the following: class Class { private: const int _id; int &_ref; public: Class(int& id) { _id = id; // not valid ref = id; // not valid } }; you must do the following: class Class { private: const int _id; int &_ref; public: Class(int& id) : _id(id), _ref(id) { // } }; int main() { int id = 20; Class obj(id); id = 25; // id is changed, _ref reflects it and _ref = 25 // _id is const and does not change (_id = 20) }","title":"Member Initialization List"},{"location":"cpp/initializer_list/#member-initializer-list","text":"Member Initializer List is a mechanism for initializing the members of a class directly. It also enables initializing const members and references, whereas the constructor cannot.","title":"Member Initializer List"},{"location":"cpp/initializer_list/#performance","text":"class Class { private: // _ is here to indicate a member is private std::string _id; std::string _data; public: Class(const std::string& id, const std::string& data) : _id(id) { this->_data = data; // other operations } }; Initializing directly with the values in the initializer list is faster than the constructor giving a default initialization then assigning the values. Initializing this->_data in the constructor function is slower than in the initializer list. You should write: class Class { private: std::string _id; std::string _data; public: Class(const std::string& id, const std::string& data) : _id(id), _data(data) { // other operations } }; The members initialized in the list are initialized in the order they are written!","title":"Performance"},{"location":"cpp/initializer_list/#const-members-and-references","text":"Const variables and references CANNOT be assigned after initialization. That is, it is not possible to do the following: class Class { private: const int _id; int &_ref; public: Class(int& id) { _id = id; // not valid ref = id; // not valid } }; you must do the following: class Class { private: const int _id; int &_ref; public: Class(int& id) : _id(id), _ref(id) { // } }; int main() { int id = 20; Class obj(id); id = 25; // id is changed, _ref reflects it and _ref = 25 // _id is const and does not change (_id = 20) }","title":"Const members and References"},{"location":"cpp/lambdas/","text":"Lambda Functions Lambda functions are used for functions that only have a use locally within the function you working in. auto lambda = [captures](parameters) { // content }; The captures refers to the variables present in the enclosing scope. That is: void function() { int b = 2; auto funcionLambda = [&]() { std::cout << b << std::endl; // can only access b }; } int main() { int a = 1; auto mainLambda = [&]() { std::cout << a << std::endl; // can only access a }; function(); } [&] will capture every variable in the scope by reference. To access a by reference, write [&a] . [=] will capture every variable in the scope by value. To access the value of the variable a, write [a] . Example: void function() { int a = 1; int b = 2; int c = 3; auto computeValueA = [&a, b](int number) { // a is captured by reference, and b by value // c is not captured a = a * b + number; }; computeValueA(4) // a is now equal to 1 * 2 + 4 = 6 }","title":"Lambda Functions"},{"location":"cpp/lambdas/#lambda-functions","text":"Lambda functions are used for functions that only have a use locally within the function you working in. auto lambda = [captures](parameters) { // content }; The captures refers to the variables present in the enclosing scope. That is: void function() { int b = 2; auto funcionLambda = [&]() { std::cout << b << std::endl; // can only access b }; } int main() { int a = 1; auto mainLambda = [&]() { std::cout << a << std::endl; // can only access a }; function(); } [&] will capture every variable in the scope by reference. To access a by reference, write [&a] . [=] will capture every variable in the scope by value. To access the value of the variable a, write [a] . Example: void function() { int a = 1; int b = 2; int c = 3; auto computeValueA = [&a, b](int number) { // a is captured by reference, and b by value // c is not captured a = a * b + number; }; computeValueA(4) // a is now equal to 1 * 2 + 4 = 6 }","title":"Lambda Functions"},{"location":"cpp/pointers_references/","text":"Pointers and References A reference is an alias of a variable, while a pointer is a variable holding the address of another variable . To be more exact, a reference is still treated as a pointer by the compiler, that automatically dereferences itself when used, is less versatile than a pointer but safer on its uses cases. Usage Use pointers for data structures, address arithmetics and everything else. Use references for function parameters and return types. Example with variables: void incrementBy(int &a, int b) { a = a + b } int main void() { int a = 6; int b = 2; incrementBy(a, b); std::cout << a << std::endl; // prints 8 return EXIT_SUCCESS; } Example with a function: void printMessage(const std::string& message) { std::cout << message << std::endl; } void callFunctionByReference(void (&funcRef)(const std::string&), const std::string& message) { funcRef(message); } int main() { callFunctionByReference(printMessage, \"Hello world!\"); return EXIT_SUCCESS; } Rules int a = 0; int *ptr = &a; // address of a int &ref = a; // ref is an alias of a Accessing the value and address : std::cout << *ptr << std::endl; // displays the value of a std::cout << ref << std::endl; // displays the value of a std::cout << ptr << std::endl; // displays the address of a std::cout << &ref << std::endl; // displays the address of a NULL : A reference cannot be null, a pointer can be. A reference must always be initialized. // valid int *ptr; int *ptr2 = nullptr; // not valid int &ref; Reassignation : A reference cannot be reassigned after initialization. A pointer can be reassigned as many times as you need. int a; int b; int *ptr = &a; ptr = &b; // valid int *ref = a; ref = b; // not valid Indirection : A reference only offers one level of indirection, whereas pointers offer as many as you want. int a; int *ptr = &a; int **pptr = &ptr; // valid int &ref = a; int &&ref = ref; // not valid Address : References do not have their own memory space, i.e they don't have an address unlike pointers.","title":"Pointers and References"},{"location":"cpp/pointers_references/#pointers-and-references","text":"A reference is an alias of a variable, while a pointer is a variable holding the address of another variable . To be more exact, a reference is still treated as a pointer by the compiler, that automatically dereferences itself when used, is less versatile than a pointer but safer on its uses cases.","title":"Pointers and References"},{"location":"cpp/pointers_references/#usage","text":"Use pointers for data structures, address arithmetics and everything else. Use references for function parameters and return types. Example with variables: void incrementBy(int &a, int b) { a = a + b } int main void() { int a = 6; int b = 2; incrementBy(a, b); std::cout << a << std::endl; // prints 8 return EXIT_SUCCESS; } Example with a function: void printMessage(const std::string& message) { std::cout << message << std::endl; } void callFunctionByReference(void (&funcRef)(const std::string&), const std::string& message) { funcRef(message); } int main() { callFunctionByReference(printMessage, \"Hello world!\"); return EXIT_SUCCESS; }","title":"Usage"},{"location":"cpp/pointers_references/#rules","text":"int a = 0; int *ptr = &a; // address of a int &ref = a; // ref is an alias of a Accessing the value and address : std::cout << *ptr << std::endl; // displays the value of a std::cout << ref << std::endl; // displays the value of a std::cout << ptr << std::endl; // displays the address of a std::cout << &ref << std::endl; // displays the address of a NULL : A reference cannot be null, a pointer can be. A reference must always be initialized. // valid int *ptr; int *ptr2 = nullptr; // not valid int &ref; Reassignation : A reference cannot be reassigned after initialization. A pointer can be reassigned as many times as you need. int a; int b; int *ptr = &a; ptr = &b; // valid int *ref = a; ref = b; // not valid Indirection : A reference only offers one level of indirection, whereas pointers offer as many as you want. int a; int *ptr = &a; int **pptr = &ptr; // valid int &ref = a; int &&ref = ref; // not valid Address : References do not have their own memory space, i.e they don't have an address unlike pointers.","title":"Rules"},{"location":"cpp/smart_pointers/","text":"Smart Pointers (C++11) We will focus on heap-allocated objects . Common problems with raw pointers Raw pointers do not go out of scope, therefore are not destroyed automatically, this causes: Memory leaks: the user forgets to delete and the memory can overflow Dangling pointers: a pointer points to an address that has been deallocated Wild pointers: a pointer may have not been initialized to point to a valid address or object delete calls the destructor of the object first then deallocate the memory the pointer was pointing to When allocated in the heap, the object can take as much memory as the OS can provide, and must be manually deleted . Class *obj = new Class(); // allocated in the heap When allocated in the stack, the object is destroyed when going out of scope, but is limited to the size of the stack itself (a few Megabytes). Stack-allocated objects are typically used when they won't live beyond the scope of the current function. Class obj(); // allocated in the stack How Smart Pointers solve these issues Include #include <memory> to use smart pointers. Smart pointers are pointers that are self-managed, that is to say they will delete when: they go out of scope they call reset() However, smart pointers are mostly used with heap-allocated objects as the stack has its own rules of ownership and deallocation. std::unique_ptr (deprecates auto_ptr) A unique_ptr has exclusive ownership of a dynamically allocated object. If another pointer tries to copy or assign itself to the object, the compiler will raise an error. Has less overhead than shared_ptr and usually more efficient. auto obj = std::make_unique<Class>(); std::shared_ptr A shared_ptr allows multiple smart pointers to share the ownership of the object, and keeps track of how many smart pointers are pointing towards the object with use_count() . auto obj = std::make_shared<Class>(); std::weak_ptr Typically used to break circular dependency of shared pointers. Otherwise not very common. auto obj = std::make_weak<Class>();","title":"Smart Pointers"},{"location":"cpp/smart_pointers/#smart-pointers-c11","text":"We will focus on heap-allocated objects .","title":"Smart Pointers (C++11)"},{"location":"cpp/smart_pointers/#common-problems-with-raw-pointers","text":"Raw pointers do not go out of scope, therefore are not destroyed automatically, this causes: Memory leaks: the user forgets to delete and the memory can overflow Dangling pointers: a pointer points to an address that has been deallocated Wild pointers: a pointer may have not been initialized to point to a valid address or object delete calls the destructor of the object first then deallocate the memory the pointer was pointing to When allocated in the heap, the object can take as much memory as the OS can provide, and must be manually deleted . Class *obj = new Class(); // allocated in the heap When allocated in the stack, the object is destroyed when going out of scope, but is limited to the size of the stack itself (a few Megabytes). Stack-allocated objects are typically used when they won't live beyond the scope of the current function. Class obj(); // allocated in the stack","title":"Common problems with raw pointers"},{"location":"cpp/smart_pointers/#how-smart-pointers-solve-these-issues","text":"Include #include <memory> to use smart pointers. Smart pointers are pointers that are self-managed, that is to say they will delete when: they go out of scope they call reset() However, smart pointers are mostly used with heap-allocated objects as the stack has its own rules of ownership and deallocation.","title":"How Smart Pointers solve these issues"},{"location":"cpp/smart_pointers/#stdunique_ptr-deprecates-auto_ptr","text":"A unique_ptr has exclusive ownership of a dynamically allocated object. If another pointer tries to copy or assign itself to the object, the compiler will raise an error. Has less overhead than shared_ptr and usually more efficient. auto obj = std::make_unique<Class>();","title":"std::unique_ptr (deprecates auto_ptr)"},{"location":"cpp/smart_pointers/#stdshared_ptr","text":"A shared_ptr allows multiple smart pointers to share the ownership of the object, and keeps track of how many smart pointers are pointing towards the object with use_count() . auto obj = std::make_shared<Class>();","title":"std::shared_ptr"},{"location":"cpp/smart_pointers/#stdweak_ptr","text":"Typically used to break circular dependency of shared pointers. Otherwise not very common. auto obj = std::make_weak<Class>();","title":"std::weak_ptr"},{"location":"cpp/static/","text":"Static Static variable A static variable are initialized only once and hold the value even when going out of the function. Their lifetime persists through the lifetime of the program itself. Global variables have a lifetime that begins before the programs starts! For a static variable, it is only during the execution. void function() { static int count = 0; count += 2; std::cout << count << std::endl; } // OUTPUT: 0 2 4 6 8 int main() { for (int i = 0; i < 5; ++i) function(); return EXIT_SUCCESS; } Static member variable A static variable is a variable shared among all the objects of the class. It is not initialized in the constructor, and must be initialized outside of the class. class Class { public: static int instancesNumber; } int Class:instancesNumber = 0; Static member function A static function is a function associated to the Class itself rather than its objects. As such, static functions can only manipulate static variables, but such functions can be called even without an instance of the Class! class Class { public: static int number; static void incrementNumber() { number += 1; } } // The initialization is made outside the main // Else, each time function would be called, it would reset to 50 // This holds for main() as well, for good practice measures int Class:number = 50; int function() { Class:incrementNumber(); } Note that static function do not have access to the this pointer.","title":"Static"},{"location":"cpp/static/#static","text":"","title":"Static"},{"location":"cpp/static/#static-variable","text":"A static variable are initialized only once and hold the value even when going out of the function. Their lifetime persists through the lifetime of the program itself. Global variables have a lifetime that begins before the programs starts! For a static variable, it is only during the execution. void function() { static int count = 0; count += 2; std::cout << count << std::endl; } // OUTPUT: 0 2 4 6 8 int main() { for (int i = 0; i < 5; ++i) function(); return EXIT_SUCCESS; }","title":"Static variable"},{"location":"cpp/static/#static-member-variable","text":"A static variable is a variable shared among all the objects of the class. It is not initialized in the constructor, and must be initialized outside of the class. class Class { public: static int instancesNumber; } int Class:instancesNumber = 0;","title":"Static member variable"},{"location":"cpp/static/#static-member-function","text":"A static function is a function associated to the Class itself rather than its objects. As such, static functions can only manipulate static variables, but such functions can be called even without an instance of the Class! class Class { public: static int number; static void incrementNumber() { number += 1; } } // The initialization is made outside the main // Else, each time function would be called, it would reset to 50 // This holds for main() as well, for good practice measures int Class:number = 50; int function() { Class:incrementNumber(); } Note that static function do not have access to the this pointer.","title":"Static member function"},{"location":"cpp/type_casting/","text":"Why casting is needed static_cast, reinterpret_cast, ... reinterpret_cast technically is the most unsafe one, but is the one we will mostly use since we are already messing with the memory and trying to forcefully cast values. StackOverflow: When should static_cast, dynamic_cast, const_cast, and reinterpret_cast be used?","title":"Type Casting"},{"location":"cpp/type_casting/#why-casting-is-needed","text":"","title":"Why casting is needed"},{"location":"cpp/type_casting/#static_cast-reinterpret_cast","text":"reinterpret_cast technically is the most unsafe one, but is the one we will mostly use since we are already messing with the memory and trying to forcefully cast values. StackOverflow: When should static_cast, dynamic_cast, const_cast, and reinterpret_cast be used?","title":"static_cast, reinterpret_cast, ..."},{"location":"cpp/vtables/","text":"vtables A vtable (or vftable , for virtual functions table) is how most C++ implementations do polymorphism. class ParentClass { public virtual void virtualFunction() { // Parent Implementation } public virtual void pureVirtualFunction() = 0; } class ChildClass : ParentClass { public override void virtualFunction() { // Child Implementation, overriding's Parent Implementation } } Each class derived from a base class have their own table of function pointers containing all virtual methods they implemented from the base class. When one calls a virtual method, we look up the object's vtable and call the appropriate derived class method. What is a vtable in C++ (StackOverflow) ParentClass ChildClass addr_vtable+0x0 *destructor() *destructor() addr_vtable+0x4 *virtualFunction() *virtualFunction() addr_vtable+0x8 *pureVirtualFunction() The offset of the functions may vary, ParentClass' and ChildClass' virtualFunction() pointers are not necessarily both at addr_vtable+0x4 . ParentClass vtable's pointers to destructor() and virtualFunction() are different from the ones in ChildClass' vtable. Even if we call it a table, a vtable is a list of function pointers, hence why the addresses of each function is incremented by 0x4. The first pointer of a vtable ALWAYS points to the destructor! That is, if the destructor was defined as virtual. (Here, at 0x85A3C4) Since all child classes inherit the virtual functions, the destructor is always the first function to be so. Constructors are not in the vtable however, as they cannot be virtual. Note: when a class is created, even if the destructor is not explicitly defined, the compiler generates a default destructor. Therefore all inheriting classes will inherit this destructor. Still, it is pretty unsafe to not have a virtual destructor when having children classes, because of potential unproper cleanups. Here, most of the guesswork has already been done, but the functions here are natively named FUN_<ADDRESS> . When the decompiled code refers to a function in the vtable, it may appear as object + 0x<Offset> .","title":"vtables"},{"location":"cpp/vtables/#vtables","text":"A vtable (or vftable , for virtual functions table) is how most C++ implementations do polymorphism. class ParentClass { public virtual void virtualFunction() { // Parent Implementation } public virtual void pureVirtualFunction() = 0; } class ChildClass : ParentClass { public override void virtualFunction() { // Child Implementation, overriding's Parent Implementation } } Each class derived from a base class have their own table of function pointers containing all virtual methods they implemented from the base class. When one calls a virtual method, we look up the object's vtable and call the appropriate derived class method. What is a vtable in C++ (StackOverflow) ParentClass ChildClass addr_vtable+0x0 *destructor() *destructor() addr_vtable+0x4 *virtualFunction() *virtualFunction() addr_vtable+0x8 *pureVirtualFunction() The offset of the functions may vary, ParentClass' and ChildClass' virtualFunction() pointers are not necessarily both at addr_vtable+0x4 . ParentClass vtable's pointers to destructor() and virtualFunction() are different from the ones in ChildClass' vtable. Even if we call it a table, a vtable is a list of function pointers, hence why the addresses of each function is incremented by 0x4. The first pointer of a vtable ALWAYS points to the destructor! That is, if the destructor was defined as virtual. (Here, at 0x85A3C4) Since all child classes inherit the virtual functions, the destructor is always the first function to be so. Constructors are not in the vtable however, as they cannot be virtual. Note: when a class is created, even if the destructor is not explicitly defined, the compiler generates a default destructor. Therefore all inheriting classes will inherit this destructor. Still, it is pretty unsafe to not have a virtual destructor when having children classes, because of potential unproper cleanups. Here, most of the guesswork has already been done, but the functions here are natively named FUN_<ADDRESS> . When the decompiled code refers to a function in the vtable, it may appear as object + 0x<Offset> .","title":"vtables"},{"location":"else/create_symlink/","text":"Creating a Symbolic Link (Symlink) A Symbolic Link is a file that points to another file or directory. It is used for \"connecting\" a folder to another, like in the case of assets, you will not be required to move your assets output directory to the project itself. Command line: mklink /D \"C:\\Pictures\\assets\" \"C:\\git\\project\\assets\" The folder in the second string must not exist before! Deleting a SymLink has no effect on any file. It also must be manually updated.","title":"Create a Symbolic Link"},{"location":"else/create_symlink/#creating-a-symbolic-link-symlink","text":"A Symbolic Link is a file that points to another file or directory. It is used for \"connecting\" a folder to another, like in the case of assets, you will not be required to move your assets output directory to the project itself. Command line: mklink /D \"C:\\Pictures\\assets\" \"C:\\git\\project\\assets\" The folder in the second string must not exist before! Deleting a SymLink has no effect on any file. It also must be manually updated.","title":"Creating a Symbolic Link (Symlink)"},{"location":"ghidra/calling_conventions/","text":"Calling Conventions A Calling Convention indicates how the compiler should: - give the args to the function CALL - tell which registers the callee must preserve for the caller - indicate whether the callee or the caller shoud clean up the stack __cdecl is the default convention call for C/C++ programs returnType function(argn, ..., arg2, arg1) ECX and EDX are general-purposes registers that can be used to pass args The other registers can be modified __stdcall is not the default convention call despite the name \"standard call\" returnType function(argn, ..., arg2, arg1) Does not allow for variable-length arg list The callee clears the stack before returning (RET 0x4 clears the top 4 bytes on the stack. It doesn't return 4.) __fastcall returnType function(arg1, arg2, ..., argn) // args are passed left to right! The two first args are passed in ECX and EDX (if they have the size of a DWORD or below) The other args are PUSHed in the stack like other call conventions would do The callee cleans the stack. __thiscall is the default convention call for member methods , C++ exclusive returnType function(argn, ..., arg2, *this) Microsoft Specific *this is passed through ECX the other args are passed through the stack The callee cleans the stack. unknown Sometimes the calling convention used does not correspond to anything used commonly. In cases like these, you will have to guess on your own how the function is called. When writing the hook, you will have to type your own __declspec(naked) function and write in ASM to manage the registers and write the instructions yourself.","title":"Calling conventions"},{"location":"ghidra/calling_conventions/#calling-conventions","text":"A Calling Convention indicates how the compiler should: - give the args to the function CALL - tell which registers the callee must preserve for the caller - indicate whether the callee or the caller shoud clean up the stack __cdecl is the default convention call for C/C++ programs returnType function(argn, ..., arg2, arg1) ECX and EDX are general-purposes registers that can be used to pass args The other registers can be modified __stdcall is not the default convention call despite the name \"standard call\" returnType function(argn, ..., arg2, arg1) Does not allow for variable-length arg list The callee clears the stack before returning (RET 0x4 clears the top 4 bytes on the stack. It doesn't return 4.) __fastcall returnType function(arg1, arg2, ..., argn) // args are passed left to right! The two first args are passed in ECX and EDX (if they have the size of a DWORD or below) The other args are PUSHed in the stack like other call conventions would do The callee cleans the stack. __thiscall is the default convention call for member methods , C++ exclusive returnType function(argn, ..., arg2, *this) Microsoft Specific *this is passed through ECX the other args are passed through the stack The callee cleans the stack. unknown Sometimes the calling convention used does not correspond to anything used commonly. In cases like these, you will have to guess on your own how the function is called. When writing the hook, you will have to type your own __declspec(naked) function and write in ASM to manage the registers and write the instructions yourself.","title":"Calling Conventions"},{"location":"ghidra/ghidra_setup/","text":"Setting up Ghidra Get the version of your choice here: Ghidra Github Releases Get Java JRE and JDK Install Java JRE (any version should do). For Ghidra 9.1.2 (the one that I use), install between JDK11 and JDK15. Ghidra 10 should support between JDK17 and JDK20.","title":"Setup"},{"location":"ghidra/ghidra_setup/#setting-up-ghidra","text":"Get the version of your choice here: Ghidra Github Releases","title":"Setting up Ghidra"},{"location":"ghidra/ghidra_setup/#get-java-jre-and-jdk","text":"Install Java JRE (any version should do). For Ghidra 9.1.2 (the one that I use), install between JDK11 and JDK15. Ghidra 10 should support between JDK17 and JDK20.","title":"Get Java JRE and JDK"},{"location":"ghidra/hierarchy/","text":"Find the hierarchy of the program To understand what does a part of the program , it is never a bad thing to understand what it does globally. Indeed, a program will have key sections like: the entry point the main loop inputs handling the game logic rendering The entry point .exe files have a common entry point named entry . .DLL files will most likely have an init entry point. Searching more locally Getting the entry point is all good, but not necessarily what you need especially if you are looking for the logic of class methods. Click on a function and hit Shift+F and explore which functions call the one you selected. If there is only one result, you're most probably on a good track, else you will have to dig around. Here, it is called by a pointer of a vtable. If you are looking for the main logic, then better find another function to start from.","title":"Find the Hierarchy"},{"location":"ghidra/hierarchy/#find-the-hierarchy-of-the-program","text":"To understand what does a part of the program , it is never a bad thing to understand what it does globally. Indeed, a program will have key sections like: the entry point the main loop inputs handling the game logic rendering","title":"Find the hierarchy of the program"},{"location":"ghidra/hierarchy/#the-entry-point","text":".exe files have a common entry point named entry . .DLL files will most likely have an init entry point.","title":"The entry point"},{"location":"ghidra/hierarchy/#searching-more-locally","text":"Getting the entry point is all good, but not necessarily what you need especially if you are looking for the logic of class methods. Click on a function and hit Shift+F and explore which functions call the one you selected. If there is only one result, you're most probably on a good track, else you will have to dig around. Here, it is called by a pointer of a vtable. If you are looking for the main logic, then better find another function to start from.","title":"Searching more locally"},{"location":"ghidra/keybinds/","text":"Keybinds I recommend to change some keybinds for making your life easier when navigating the decompiled code: Edit > Tool Options... > Key Bindings and edit the following Previous in History Buffer: change Alt+Left to Ctrl+Left Next in History Buffer: change Alt+Right to Ctrl+Right Find References To Symbol: set it to Shift+F These three features are the core of a smooth search in Ghidra.","title":"Keybinds"},{"location":"ghidra/keybinds/#keybinds","text":"I recommend to change some keybinds for making your life easier when navigating the decompiled code: Edit > Tool Options... > Key Bindings and edit the following Previous in History Buffer: change Alt+Left to Ctrl+Left Next in History Buffer: change Alt+Right to Ctrl+Right Find References To Symbol: set it to Shift+F These three features are the core of a smooth search in Ghidra.","title":"Keybinds"},{"location":"ghidra/naming_conventions/","text":"Ghidra's naming and how to read them FUN_<ADDRESS> : Function at <address> DAT_<ADDRESS> : Data at <address> LAB_<ADDRESS> : Label at <address>, it is a function, struct, data or variable that was not defined by the developer themself. A same var can be used for different purposes. A bit troublesome. 0xffffffff = -1 in unsigned 0xbf800000 = -1 in floating point 0x3f800000 = 1 in floating point How to rename without getting lost It is all good being able to navigate in the decompiled code and finding strings, but you need to sort this mess in a human-readable way, for yourself and others. Hit l to rename functions, labels, data or variables. Don't try to rename things you are too unsure of. u_<nameOfYourGuess> for functions, variables or whatever that you aren't sure of. u_ stands for unknown.","title":"Naming conventions"},{"location":"ghidra/naming_conventions/#ghidras-naming-and-how-to-read-them","text":"FUN_<ADDRESS> : Function at <address> DAT_<ADDRESS> : Data at <address> LAB_<ADDRESS> : Label at <address>, it is a function, struct, data or variable that was not defined by the developer themself. A same var can be used for different purposes. A bit troublesome. 0xffffffff = -1 in unsigned 0xbf800000 = -1 in floating point 0x3f800000 = 1 in floating point","title":"Ghidra's naming and how to read them"},{"location":"ghidra/naming_conventions/#how-to-rename-without-getting-lost","text":"It is all good being able to navigate in the decompiled code and finding strings, but you need to sort this mess in a human-readable way, for yourself and others. Hit l to rename functions, labels, data or variables. Don't try to rename things you are too unsure of. u_<nameOfYourGuess> for functions, variables or whatever that you aren't sure of. u_ stands for unknown.","title":"How to rename without getting lost"},{"location":"ghidra/new_project/","text":"New Project When launching Ghidra, you are faced with a project launcher. Create a project directory to hold the project you will work in Put a copy of the file you want to examine in this folder File > New Project... in non-shared, indicate the folder you just created and continue Drag&Drop the file onto the launcher where the named folder is Double-click the file to open it The default parameters should be fine, let Ghidra disassemble/decompile your file for a few minutes* You can now start digging *Ghidra may complain that there is no PDB. Ignore it. The PDB is the debugging file only present in the Debug mode of the executable/dll/file, or more realistically only to the original developers. It contains the names of all functions, variables and anything else, and it's precisely because you are missing this file that you will spend hours finding out what this FUN_006452C2 does.","title":"Open a new Project"},{"location":"ghidra/new_project/#new-project","text":"When launching Ghidra, you are faced with a project launcher. Create a project directory to hold the project you will work in Put a copy of the file you want to examine in this folder File > New Project... in non-shared, indicate the folder you just created and continue Drag&Drop the file onto the launcher where the named folder is Double-click the file to open it The default parameters should be fine, let Ghidra disassemble/decompile your file for a few minutes* You can now start digging *Ghidra may complain that there is no PDB. Ignore it. The PDB is the debugging file only present in the Debug mode of the executable/dll/file, or more realistically only to the original developers. It contains the names of all functions, variables and anything else, and it's precisely because you are missing this file that you will spend hours finding out what this FUN_006452C2 does.","title":"New Project"},{"location":"ghidra/search_for_strings/","text":"Search for String One of the fastest and easiest approach when digging through decompiled code is to look for strings. Search > For Strings... with the default parameters should be fine. The strength of this method of approach is that it is really efficient when inspecting code that is very susceptible to have debug functions in it, such as console messages ( std::cout and the likes). Though, you will have to ignore the very many system strings present in the results... However, this method can be unreliable for games as their Release version may not contain any trace of debug logging. Still, a very quick and efficient way to easily guess portions of code.","title":"Search for Strings"},{"location":"ghidra/search_for_strings/#search-for-string","text":"One of the fastest and easiest approach when digging through decompiled code is to look for strings. Search > For Strings... with the default parameters should be fine. The strength of this method of approach is that it is really efficient when inspecting code that is very susceptible to have debug functions in it, such as console messages ( std::cout and the likes). Though, you will have to ignore the very many system strings present in the results... However, this method can be unreliable for games as their Release version may not contain any trace of debug logging. Still, a very quick and efficient way to easily guess portions of code.","title":"Search for String"},{"location":"git/git/","text":"Git Git is used both locally (your project directory) and remotely (github/gitlab) for version controlling. This means creating saves and a history of what has been done during the whole project. However, those saves can be edited to your liking to make \"cleaner\" saves and the history can be edited as well to reflect a clean timeline. Cleaning your code before even using Git Install pre-commit on your computer: pip install pre-commit Install pre-commit in your repository: pre-commit install Before any git add, run pre-commit run --all so your code is all nicely formatted Congrats, you don't even have to bother with indenting yourself. Hash Commits all have a hash , an identifier so to speak. HEAD is the pointer to the latest commit you performed(?) commit d66b78231f26cb7cf738678bea1d081b8b4def71 (HEAD -> main, origin/main) Author: PC_volt <this is private> Date: Sun Aug 6 18:40:14 2023 +0200 You can point anywhere, but if you are not pointing to the HEAD, you will be in a detached HEAD state. Git the easy and dirty way It is dirty in the sense that you have no care for the history and only the result counts. This is acceptable for smaller projects, or don't want to bother if you are in a small team. git add -A git commit -m \"<msg>\" git push","title":"Git"},{"location":"git/git/#git","text":"Git is used both locally (your project directory) and remotely (github/gitlab) for version controlling. This means creating saves and a history of what has been done during the whole project. However, those saves can be edited to your liking to make \"cleaner\" saves and the history can be edited as well to reflect a clean timeline.","title":"Git"},{"location":"git/git/#cleaning-your-code-before-even-using-git","text":"Install pre-commit on your computer: pip install pre-commit Install pre-commit in your repository: pre-commit install Before any git add, run pre-commit run --all so your code is all nicely formatted Congrats, you don't even have to bother with indenting yourself.","title":"Cleaning your code before even using Git"},{"location":"git/git/#hash","text":"Commits all have a hash , an identifier so to speak. HEAD is the pointer to the latest commit you performed(?) commit d66b78231f26cb7cf738678bea1d081b8b4def71 (HEAD -> main, origin/main) Author: PC_volt <this is private> Date: Sun Aug 6 18:40:14 2023 +0200 You can point anywhere, but if you are not pointing to the HEAD, you will be in a detached HEAD state.","title":"Hash"},{"location":"git/git/#git-the-easy-and-dirty-way","text":"It is dirty in the sense that you have no care for the history and only the result counts. This is acceptable for smaller projects, or don't want to bother if you are in a small team. git add -A git commit -m \"<msg>\" git push","title":"Git the easy and dirty way"},{"location":"git/git_branches/","text":"Git Branches Branches are made to work in a parallel environment. You choose which commit to create a branch of off (usually the latest commit of main) and can choose This is the defining feature that allows collaboration without overstepping on someone else's work, while still be able to share it. git branch <branch-name> Creates the branch. git checkout <branch-name> Switches to the branch. git checkout -b <branch-name> Creates the branch and switch to it.","title":"Git Branches"},{"location":"git/git_branches/#git-branches","text":"Branches are made to work in a parallel environment. You choose which commit to create a branch of off (usually the latest commit of main) and can choose This is the defining feature that allows collaboration without overstepping on someone else's work, while still be able to share it. git branch <branch-name> Creates the branch. git checkout <branch-name> Switches to the branch. git checkout -b <branch-name> Creates the branch and switch to it.","title":"Git Branches"},{"location":"git/git_history_commands/","text":"Git History Commands These commands will tamper with the history, rewriting it to make it easier to trace what was done, and divide the commits into the implementation of the features separately rather than everything at the same time. More here : Atlassian: Rewriting History Git Commit --amend Note that the modified commits are actually new commits. Be very careful not to --amend a commit on which someone else is developing. git commit --amend -m \"message\" modifies the commit and replaces the message. git commit --amend --no-edit modifies the commit without changing the original message. Git Reset Git reset moves the HEAD git reset HEAD Git Rebase Git Rebase is a means to update your feature branch with the main as the source, without creating a commit each time you have to update your feature branch! Let's see how it works. Problem: we want to update our feature branch with the latest changes applied on the main. // Solution #1: MERGE git checkout feature git merge main As you can see, every update we will be doing will require an extra commit, which on big project. // Solution #2: REBASE git checkout feature git rebase main Here, the feature branch is replayed from the HEAD of the main. Each commit of the branch becomes a new commit with a different hash. This has various benefits: - the history of the branch is linear and easy to read - there is no fork, you don't have to check when the updates from main occurred since everything is based on the main's latest commit NEVER REBASE A PUBLIC BRANCH! NEVER REBASE A BRANCH SHARED WITH SOMEONE ELSE! Since it rewrites the history and discards previous commits to make new commits. It is a destructive operation! --squash and --autosquash Because of this, you may have to force push: git push --force pushes your rewritten history, does not preserve new commits from other people in the remote git push --force-with-lease pushes your rewritten history only if there are new commits. This prevents from forcefully pushing and erasing the work from others. Use git fetch git rebase --interactive --autosquash Video: Git Rebase in 6 minutes Atlassian: Merge vs Rebase Git Revert git revert <commit-hash>","title":"Git History Commands"},{"location":"git/git_history_commands/#git-history-commands","text":"These commands will tamper with the history, rewriting it to make it easier to trace what was done, and divide the commits into the implementation of the features separately rather than everything at the same time. More here : Atlassian: Rewriting History","title":"Git History Commands"},{"location":"git/git_history_commands/#git-commit-amend","text":"Note that the modified commits are actually new commits. Be very careful not to --amend a commit on which someone else is developing. git commit --amend -m \"message\" modifies the commit and replaces the message. git commit --amend --no-edit modifies the commit without changing the original message.","title":"Git Commit --amend"},{"location":"git/git_history_commands/#git-reset","text":"Git reset moves the HEAD git reset HEAD","title":"Git Reset"},{"location":"git/git_history_commands/#git-rebase","text":"Git Rebase is a means to update your feature branch with the main as the source, without creating a commit each time you have to update your feature branch! Let's see how it works. Problem: we want to update our feature branch with the latest changes applied on the main. // Solution #1: MERGE git checkout feature git merge main As you can see, every update we will be doing will require an extra commit, which on big project. // Solution #2: REBASE git checkout feature git rebase main Here, the feature branch is replayed from the HEAD of the main. Each commit of the branch becomes a new commit with a different hash. This has various benefits: - the history of the branch is linear and easy to read - there is no fork, you don't have to check when the updates from main occurred since everything is based on the main's latest commit NEVER REBASE A PUBLIC BRANCH! NEVER REBASE A BRANCH SHARED WITH SOMEONE ELSE! Since it rewrites the history and discards previous commits to make new commits. It is a destructive operation!","title":"Git Rebase"},{"location":"git/git_history_commands/#-squash-and-autosquash","text":"Because of this, you may have to force push: git push --force pushes your rewritten history, does not preserve new commits from other people in the remote git push --force-with-lease pushes your rewritten history only if there are new commits. This prevents from forcefully pushing and erasing the work from others. Use git fetch git rebase --interactive --autosquash Video: Git Rebase in 6 minutes Atlassian: Merge vs Rebase","title":"--squash and --autosquash"},{"location":"git/git_history_commands/#git-revert","text":"git revert <commit-hash>","title":"Git Revert"},{"location":"git/git_local_commands/","text":"Git Local Commands Rundown of the most common git commands. Git Add git add <file1 file2 ...> Stages the indicated files. Useful if you want to specifically stage a few files, otherwise, use the next command. git add --all or git add -A The git add command by default! It stages the entire repository, be it new files, modifications and deletions. git add -p ( -p stands for patch) Allows you to interactively review and apply patches on the code you want to stage. This inherently makes your files in your repository potentially different from the files you are staging for the commit. Hunks are groups of differing lines, and you decide which actions to apply: y : stage this hunk n : do not stage this hunk s : split into smaller hunks e : edit this hunk q : quit and do not stage any more hunks ? : help As you can see, this is the most complex but most useful for keeping a clean history, free of commented-out portion of codes. Git Commit git commit -m <msg> The standard git commit. Use this. git commit --amend When you did a little mistake on the content or the commit message, and don't want to make a fully dedicated commit to fixing it. You then just edit the latest commit with this. Other commands ``git add .`` (``.`` stands for the current directory) This command works like ``git add --all`` but: - it does **not** stage file deletions - it does **not** stage anything above the current directory ``git add -u`` (``-u`` stands for update) This command works like ``git add --all`` but: - it does **not** stage new files - it does **not** stage anything above the current directory ``git add -i`` (``-i`` stands for interactive) This command provides an interface to perform diverse tasks like status, update, revert, add, patch or diff. Maybe the most interesting but complex command here. ``git commit -p`` Works just like git add -p, but for commits. Using the staged files (with any git add command), you can decide the patches to apply to the files that will be committed.","title":"Git Local Commands"},{"location":"git/git_local_commands/#git-local-commands","text":"Rundown of the most common git commands.","title":"Git Local Commands"},{"location":"git/git_local_commands/#git-add","text":"git add <file1 file2 ...> Stages the indicated files. Useful if you want to specifically stage a few files, otherwise, use the next command. git add --all or git add -A The git add command by default! It stages the entire repository, be it new files, modifications and deletions. git add -p ( -p stands for patch) Allows you to interactively review and apply patches on the code you want to stage. This inherently makes your files in your repository potentially different from the files you are staging for the commit. Hunks are groups of differing lines, and you decide which actions to apply: y : stage this hunk n : do not stage this hunk s : split into smaller hunks e : edit this hunk q : quit and do not stage any more hunks ? : help As you can see, this is the most complex but most useful for keeping a clean history, free of commented-out portion of codes.","title":"Git Add"},{"location":"git/git_local_commands/#git-commit","text":"git commit -m <msg> The standard git commit. Use this. git commit --amend When you did a little mistake on the content or the commit message, and don't want to make a fully dedicated commit to fixing it. You then just edit the latest commit with this. Other commands ``git add .`` (``.`` stands for the current directory) This command works like ``git add --all`` but: - it does **not** stage file deletions - it does **not** stage anything above the current directory ``git add -u`` (``-u`` stands for update) This command works like ``git add --all`` but: - it does **not** stage new files - it does **not** stage anything above the current directory ``git add -i`` (``-i`` stands for interactive) This command provides an interface to perform diverse tasks like status, update, revert, add, patch or diff. Maybe the most interesting but complex command here. ``git commit -p`` Works just like git add -p, but for commits. Using the staged files (with any git add command), you can decide the patches to apply to the files that will be committed.","title":"Git Commit"},{"location":"git/git_remote_commands/","text":"Git Remote Commands These commands are aimed to be used when you have a remote repository like Github or Gitlab set up. Git Fetch git fetch Fetches the changes from the remote but doesn't incorporate them into the local. Use git merge or git rebase to get your local repository updated. Git Pull git pull It is essentially a git fetch followed by a git merge . Pulls the commits of the remote repository into the local repository. Always do this before pushing to avoid conflicts. Git Push git push Pushes the committed changes towards the remote repository. When the history of the commits doesn't match the one in the remote, this is when you will may have to use responsibly the --force flag.","title":"Git Remote Commands"},{"location":"git/git_remote_commands/#git-remote-commands","text":"These commands are aimed to be used when you have a remote repository like Github or Gitlab set up.","title":"Git Remote Commands"},{"location":"git/git_remote_commands/#git-fetch","text":"git fetch Fetches the changes from the remote but doesn't incorporate them into the local. Use git merge or git rebase to get your local repository updated.","title":"Git Fetch"},{"location":"git/git_remote_commands/#git-pull","text":"git pull It is essentially a git fetch followed by a git merge . Pulls the commits of the remote repository into the local repository. Always do this before pushing to avoid conflicts.","title":"Git Pull"},{"location":"git/git_remote_commands/#git-push","text":"git push Pushes the committed changes towards the remote repository. When the history of the commits doesn't match the one in the remote, this is when you will may have to use responsibly the --force flag.","title":"Git Push"},{"location":"git/git_submodules/","text":"","title":"Git Submodules"}]}